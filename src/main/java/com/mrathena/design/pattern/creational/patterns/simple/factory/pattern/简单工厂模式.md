
工厂模式

---

简单工厂模式

理解:

根据传入工厂方法的参数不同，生成并返回对应的抽象产品子类对象，
对客户端隐藏了对象的创建细节, 降低了耦合性, 
但扩展新产品时需要修改工厂方法，违反开闭原则

实现:

一个产品接口一个工厂类多个具体产品类，工厂类有一个生产方法，根据入参生成对应的子类产品实例，在客户端通过直接调用工厂的静态方法创建对象

---

工厂方法模式

理解:

在简单工厂模式的基础上，核心的工厂类不再负责所有的产品的创建，而是将具体创建的工作交给子类去做。
该核心类成为一个抽象工厂角色，仅负责给出具体工厂子类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。
扩展新产品只需要添加新产品类和其对应的工厂类就好了，更符合开闭原则

实现:

一个产品接口一个工厂接口多个具体产品和具体工厂的组合，每一个具体的产品都一一对应一个具体的工厂，成对添加，在客户端直接new具体的工厂类，然后调用生产方法

---

抽象工厂模式

https://www.runoob.com/design-pattern/abstract-factory-pattern.html 下面的第一个笔记

理解:

在工厂方法模式的基础上, 抽象工厂扩展为可以创建多种产品(返回值是不同的抽象产品), 每种产品仍然由其对应的工厂子类去创建; 
当抽象产品只有一种的时候, 抽象工厂模式即变成工厂模式. 当工厂方法模式的抽象产品变成多个时, 工厂方法模式即变成抽象工厂模式

实现:

在工厂方法模式的基础上, 抽象工厂扩展为可以创建多种产品(返回值是不同的抽象产品), 其子类实现抽象工厂的所有方法, 创建不同类型的具体产品; 
再添加一个 抽象工厂提供者(简单工厂模式), 通过传入不同参数, 创建对应的子类工厂, 然后再创建对应的子类产品
