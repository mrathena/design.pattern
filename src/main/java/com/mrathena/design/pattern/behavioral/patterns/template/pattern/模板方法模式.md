定义一个操作中算法的骨架，而将一些步骤延迟到子类中。模板方法可以不改变一个算法的结构即可重新定义该算法的某些特定步骤。


例子中的可自定义实现的方法有两种写法，可以写成abstract方法，让子类必须实现，也可以给出默认实现，如抛出不支持异常，由子类有选择的实现
考虑如下场景
一个抽象类提供了两个算法，第一个调用了ab两个抽象方法，第二个调用了ac两个抽象方法
假设子类只需要使用到抽象类定义的算法一，
使用上述的第一种写法，除了ab，还得把c也实现了，虽然用不到c。使用第二种方法，只需要手动选择覆盖需要自定义的ab即可，无需在子类中把c也覆盖一遍


模板方法模式中，抽象父类一定定义了一个或多个包含多个步骤的模板方法


其实可以这样理解抽象父类与子类的关系
抽象的父类方法-子类必须得实现
普通的非空父类方法-子类可以选择是否覆盖，覆盖就是自定义流程，不覆盖就是默认流程
普通的空父类方法-子类可以选择是否覆盖，不覆盖可以认为是子类跳过了这一步
抛不支持的父类方法-子类用到的话就必须覆盖，即使是想要跳过，不用可以不管



